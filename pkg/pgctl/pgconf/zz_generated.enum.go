/*
Package pgconf GENERATED BY gengo:enum
DON'T EDIT THIS FILE
*/
package pgconf

import (
	bytes "bytes"
	driver "database/sql/driver"
	errors "errors"
	fmt "fmt"

	enumeration "github.com/octohelm/enumeration/pkg/enumeration"
	pkgscanner "github.com/octohelm/enumeration/pkg/scanner"
)

var InvalidApplicationType = errors.New("invalid ApplicationType")

func (ApplicationType) EnumValues() []any {
	return []any{
		APPLICATION_TYPE__WEB, APPLICATION_TYPE__OLTP, APPLICATION_TYPE__DATA_WAREHOUSE, APPLICATION_TYPE__DESKTOP, APPLICATION_TYPE__MIXED,
	}
}

func (v ApplicationType) MarshalText() ([]byte, error) {
	return []byte(v.String()), nil
}

func (v *ApplicationType) UnmarshalText(data []byte) error {
	vv, err := ParseApplicationTypeFromString(string(bytes.ToUpper(data)))
	if err != nil {
		return err
	}
	*v = vv
	return nil
}

func ParseApplicationTypeFromString(s string) (ApplicationType, error) {
	switch s {
	case "WEB":
		return APPLICATION_TYPE__WEB, nil
	case "OLTP":
		return APPLICATION_TYPE__OLTP, nil
	case "DATA_WAREHOUSE":
		return APPLICATION_TYPE__DATA_WAREHOUSE, nil
	case "DESKTOP":
		return APPLICATION_TYPE__DESKTOP, nil
	case "MIXED":
		return APPLICATION_TYPE__MIXED, nil

	default:
		var i ApplicationType
		_, err := fmt.Sscanf(s, "UNKNOWN_%d", &i)
		if err == nil {
			return i, nil
		}
		return APPLICATION_TYPE_UNKNOWN, InvalidApplicationType
	}
}

func (v ApplicationType) IsZero() bool {
	return v == APPLICATION_TYPE_UNKNOWN
}

func (v ApplicationType) String() string {
	switch v {
	case APPLICATION_TYPE__WEB:
		return "WEB"
	case APPLICATION_TYPE__OLTP:
		return "OLTP"
	case APPLICATION_TYPE__DATA_WAREHOUSE:
		return "DATA_WAREHOUSE"
	case APPLICATION_TYPE__DESKTOP:
		return "DESKTOP"
	case APPLICATION_TYPE__MIXED:
		return "MIXED"

	case APPLICATION_TYPE_UNKNOWN:
		return "UNKNOWN"
	default:
		return fmt.Sprintf("UNKNOWN_%d", v)
	}
}

func ParseApplicationTypeLabelString(label string) (ApplicationType, error) {
	switch label {
	case "WEB":
		return APPLICATION_TYPE__WEB, nil
	case "OLTP":
		return APPLICATION_TYPE__OLTP, nil
	case "DATA_WAREHOUSE":
		return APPLICATION_TYPE__DATA_WAREHOUSE, nil
	case "DESKTOP":
		return APPLICATION_TYPE__DESKTOP, nil
	case "MIXED":
		return APPLICATION_TYPE__MIXED, nil

	default:
		return APPLICATION_TYPE_UNKNOWN, InvalidApplicationType
	}
}

func (v ApplicationType) Label() string {
	switch v {
	case APPLICATION_TYPE__WEB:
		return "WEB"
	case APPLICATION_TYPE__OLTP:
		return "OLTP"
	case APPLICATION_TYPE__DATA_WAREHOUSE:
		return "DATA_WAREHOUSE"
	case APPLICATION_TYPE__DESKTOP:
		return "DESKTOP"
	case APPLICATION_TYPE__MIXED:
		return "MIXED"

	default:
		return fmt.Sprint(v)
	}
}

func (v ApplicationType) Value() (driver.Value, error) {
	offset := 0
	if o, ok := any(v).(enumeration.DriverValueOffset); ok {
		offset = o.Offset()
	}
	return int64(v) + int64(offset), nil
}

func (v *ApplicationType) Scan(src any) error {
	offset := 0
	if o, ok := any(v).(enumeration.DriverValueOffset); ok {
		offset = o.Offset()
	}

	i, err := pkgscanner.ScanIntEnumStringer(src, offset)
	if err != nil {
		return err
	}
	*v = ApplicationType(i)
	return nil
}

var InvalidDiskType = errors.New("invalid DiskType")

func (DiskType) EnumValues() []any {
	return []any{
		DISK_TYPE__SSD, DISK_TYPE__HDD, DISK_TYPE__SAN,
	}
}

func (v DiskType) MarshalText() ([]byte, error) {
	return []byte(v.String()), nil
}

func (v *DiskType) UnmarshalText(data []byte) error {
	vv, err := ParseDiskTypeFromString(string(bytes.ToUpper(data)))
	if err != nil {
		return err
	}
	*v = vv
	return nil
}

func ParseDiskTypeFromString(s string) (DiskType, error) {
	switch s {
	case "SSD":
		return DISK_TYPE__SSD, nil
	case "HDD":
		return DISK_TYPE__HDD, nil
	case "SAN":
		return DISK_TYPE__SAN, nil

	default:
		var i DiskType
		_, err := fmt.Sscanf(s, "UNKNOWN_%d", &i)
		if err == nil {
			return i, nil
		}
		return DISK_TYPE_UNKNOWN, InvalidDiskType
	}
}

func (v DiskType) IsZero() bool {
	return v == DISK_TYPE_UNKNOWN
}

func (v DiskType) String() string {
	switch v {
	case DISK_TYPE__SSD:
		return "SSD"
	case DISK_TYPE__HDD:
		return "HDD"
	case DISK_TYPE__SAN:
		return "SAN"

	case DISK_TYPE_UNKNOWN:
		return "UNKNOWN"
	default:
		return fmt.Sprintf("UNKNOWN_%d", v)
	}
}

func ParseDiskTypeLabelString(label string) (DiskType, error) {
	switch label {
	case "SSD":
		return DISK_TYPE__SSD, nil
	case "HDD":
		return DISK_TYPE__HDD, nil
	case "SAN":
		return DISK_TYPE__SAN, nil

	default:
		return DISK_TYPE_UNKNOWN, InvalidDiskType
	}
}

func (v DiskType) Label() string {
	switch v {
	case DISK_TYPE__SSD:
		return "SSD"
	case DISK_TYPE__HDD:
		return "HDD"
	case DISK_TYPE__SAN:
		return "SAN"

	default:
		return fmt.Sprint(v)
	}
}

func (v DiskType) Value() (driver.Value, error) {
	offset := 0
	if o, ok := any(v).(enumeration.DriverValueOffset); ok {
		offset = o.Offset()
	}
	return int64(v) + int64(offset), nil
}

func (v *DiskType) Scan(src any) error {
	offset := 0
	if o, ok := any(v).(enumeration.DriverValueOffset); ok {
		offset = o.Offset()
	}

	i, err := pkgscanner.ScanIntEnumStringer(src, offset)
	if err != nil {
		return err
	}
	*v = DiskType(i)
	return nil
}
